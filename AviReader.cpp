// AviReader.cpp : Defines the entry point for the application.
//

// This project was generated by Visual C++
// - Project type:  Win32 Application
// - Kind:  Simple Win32 Application
// - Add library named (Vfw32.lib) to link list under
//   menu Project->Settings->Link

//#include <windows.h>
#include "iostream.h"
#include "string.h"
#include "stdlib.h"
#include "stdafx.h"  // needed by vfw.h
#include <vfw.h>     // has AVI stuff
#include "stdio.h"

int loadAviFile(char *filename, char *savefile, long frame);

// NOTE: lpCmdLine (below) contains the arguments that were passed in.
// Windows strips off the command that was passed in with the arguments

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    char cmd[256]="";                           // the original command with arguments
    char tempString[256]="";                    // temp string
    char savefile[256]="";                      // name of AviTransferFile which will be saved to disk
    char avifile[256]="";                       // path of the avifile read in
    char sframe[10]="";                         // string version of framenumber
    int framenumber;
    int len, len2;
    int pos;

    strcpy(cmd, lpCmdLine);
    _strrev(cmd);                               // reverse cmd to get

    pos = strcspn(cmd, " ");                    // find position of first space char
    strncpy(sframe, cmd, pos);                  // extract frame number
    _strrev(sframe);                            // reverse back to get right number
    _strrev(cmd);                               // reverse back to original
    framenumber = atoi(sframe);

    len = strlen(cmd)-(pos+1);                  // len of cmd without frame number
    strncpy(tempString, cmd, len);              // tempString contains cmd without frame no.

    _strrev(tempString);
    pos = strcspn(tempString, " ");
    strncpy(savefile, tempString, pos);
    _strrev(savefile);

    _strrev(tempString);
    len = strlen(savefile);
    len2 = strlen(tempString) - (len+1);
    strncpy(avifile, tempString, len2);

    int a = loadAviFile(avifile, savefile, framenumber);
    return 0;
}

// write an error message instead of the image and exit
void writeError(char *outFileName, char *message) {
    printf("%s", message);

    FILE *fp;
    fp = fopen(outFileName, "wb");

    // 4 byte little endian integers
    int errorCode = 4; // offset to start of error message
    int length = strlen(message);
    fwrite(&errorCode, 4, 1, fp);
    fwrite(message, length, 1, fp);
    fclose(fp);
    exit(1);
}

/**** NOTE: This code is a modification of code that was borrowed from
      Tracker3. The Tracker code also does 1-bit and 4-bit AVIs but since we
      have never seen one of those in practice, I cut that part out. Actually
      the only type of AVI file that we've ever seen is a 24-bit, but I left
      the 8-bit stuff there just in case.
****/

int loadAviFile(char *filename, char *savefile, long frame) {
    char loadPathName[256];
    char saveFilename[256];
    strcpy(loadPathName, filename);
    strcpy(saveFilename, savefile);

    int nbytes;
    int firstFrame = 0;
    int lastFrame = 0;
    int dibWidth = 0;
    int dibHeight = 0;
    int bitCount = 0;
    int colorPlanes = 0;
    int bitsPerPlane = 0;
    int errorCode = 0;
    char errorBuf[1000];

    PAVIFILE pfile;
    PAVISTREAM ppavi;
    PGETFRAME getFrame;
    BYTE *lpDib;
    BYTE *data;

    LONG hr;
    AVIFileInit();                              // opens AVIFile library
    hr = AVIFileOpen(&pfile, loadPathName, OF_SHARE_DENY_WRITE, 0L);
    if (hr != 0) {
        AVIFileRelease(pfile);                  // closes the file
        AVIFileExit();                          // releases AVIFile library
        sprintf(errorBuf, "AviReader: Could not open file: %s\n", loadPathName);
        writeError(saveFilename, errorBuf);
    }

    // check for valid video data
    if (0 != AVIFileGetStream(pfile, &ppavi, streamtypeVIDEO,0)) {
        AVIStreamRelease(ppavi);                // closes the stream
        AVIFileRelease(pfile);                  // closes the file
        AVIFileExit();                          // releases AVIFile library
        sprintf(errorBuf, "AviReader: No video data in file: %s\n", loadPathName);
        writeError(saveFilename, errorBuf);
    }

    firstFrame = AVIStreamStart(ppavi);
    frame += firstFrame;                        // offset in case first frame is not 0

    /*if (frame < firstFrame) {
      AVIStreamRelease(ppavi);// closes the stream
      AVIFileRelease(pfile);  // closes the file
      AVIFileExit();          // releases AVIFile library
      sprintf(errorBuf, "AviReader: Frame requested is less than 0\n");
      writeError(saveFilename, errorBuf);
      }*/

    lastFrame = AVIStreamEnd(ppavi);
    if (frame >= lastFrame) {
        AVIStreamRelease(ppavi);                // closes the stream
        AVIFileRelease(pfile);                  // closes the file
        AVIFileExit();                          // releases AVIFile library
        sprintf(errorBuf, "AviReader: Frame requested is greater than maximum number of frames in the file\n");
        writeError(saveFilename, errorBuf);
    }

    // check that the proper codec is installed
    getFrame = AVIStreamGetFrameOpen(ppavi, NULL);
    if (getFrame == NULL) {
        AVIStreamGetFrameClose(getFrame);
        AVIStreamRelease(ppavi);                // closes the stream
        AVIFileRelease(pfile);                  // closes the file
        AVIFileExit();                          // releases AVIFile library
        sprintf(errorBuf, "AviReader: Could not decompress frames. Is the right codec installed?\n");
        writeError(saveFilename, errorBuf);
    }

    void *framePtr=AVIStreamGetFrame(getFrame, frame);
    lpDib = (BYTE *) framePtr;
    if (lpDib == NULL) {
        AVIStreamGetFrameClose(getFrame);
        AVIStreamRelease(ppavi);                // closes the stream
        AVIFileRelease(pfile);                  // closes the file
        AVIFileExit();                          // releases AVIFile library
        sprintf(errorBuf, "AviReader: Could not read this frame. Maybe the AVI file is corrupt\n");
        writeError(saveFilename, errorBuf);
    }

    // read the data
    DWORD cxDib, pixel, pad;
    BYTE *lpPixel, *lpMyPixel, *lpColorTable;
    RGBQUAD *rgbInfo;
    BITMAPINFOHEADER *lpDibHeader = (BITMAPINFOHEADER *) lpDib;

    bitCount = lpDibHeader->biBitCount;         // bitCount=24 if 24-bit, else 8-bit

    dibWidth  = lpDibHeader->biWidth;
    dibHeight = lpDibHeader->biHeight;

    if(bitCount == 24) {                        // 24 bit image
        nbytes = dibWidth * dibHeight * 3;
        data = new BYTE[nbytes];
        colorPlanes = 3;
        bitsPerPlane = 8;
    }
    else {                                      // 8-bit
        nbytes = dibWidth * dibHeight;
        data = new BYTE[nbytes];
        colorPlanes = 1;
        bitsPerPlane = 8;
    }

    if (bitCount == 8) {                        // its a 8 bit image
        long c=0;
        cxDib = dibWidth;                       // 1 byte per pixel
        if (pad = cxDib%4)                      // pad end of row
            cxDib += 4 - pad;
        lpColorTable =  ((BYTE *)lpDib + (WORD)(lpDibHeader->biSize));    // address of color table
        lpPixel = lpColorTable + 256 * sizeof(RGBQUAD);                   // address of pixels
        for (int y=dibHeight-1; y>=0; y--) {
            for (int x=0; x<dibWidth; x++) {
                pixel = y*cxDib + x;                                      // index of the pixel we want
                lpMyPixel = lpPixel + pixel;                              // address of pixel we want
                rgbInfo = (RGBQUAD *) lpColorTable + *lpMyPixel;
                data[c++] = rgbInfo->rgbRed;
            }
        }
    } else if (bitCount == 24) {                // it is a 24 bit image (no color table)
        long c=0;
        cxDib = dibWidth * 3;                   // 3 bytes per pixel
        if (pad = cxDib%4)                      // pad end of row
            cxDib += 4 - pad;
        lpPixel = lpDib + lpDibHeader->biSize;  // address of pixels
        for (int y=dibHeight-1; y>=0; y--) {
            for (int x=0; x<dibWidth; x++) {
                pixel = y*cxDib + x*3;          // index of the pixel we want
                lpMyPixel = lpPixel + pixel;    // address of pixel we want
                rgbInfo = (RGBQUAD *) lpMyPixel;
                data[c++] = rgbInfo->rgbRed;
                data[c++] = rgbInfo->rgbGreen;
                data[c++] = rgbInfo->rgbBlue;
            }
        }

    }

    AVIStreamGetFrameClose(getFrame);

    FILE *fp;
    fp = fopen(saveFilename, "wb");

    // Write the header
    // 4 byte little endian integers
    fwrite(&errorCode, 4, 1, fp);
    fwrite(&lastFrame, 4, 1, fp);
    fwrite(&dibWidth, 4, 1, fp);
    fwrite(&dibHeight, 4, 1, fp);
    fwrite(&colorPlanes, 4, 1, fp);
    fwrite(&bitsPerPlane, 4, 1, fp);

    // Write the data
    fwrite(data, nbytes, 1, fp);
    delete []data;
    fclose(fp);

    return 0;
}
